1.顺序查找：
条件：无序或有序队列
原理：按顺序比较每个元素，直到找到关键字为止
时间复杂度：O(n)

2.二分查找（折半查找）：
条件：有序数组
原理：查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。
时间复杂度：O(logn)

3.二叉排序树查找：
条件：先创建二叉排序树：
  1.若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
  2.若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  3.它的左、右子树也分别为二叉排序树。
原理：在二叉查找树b中查找x的过程为：
  1.若b是空树，则搜索失败，否则：
  2.若x等于b的根节点的数据域之值，则查找成功；否则：
  3.若x小于b的根节点的数据域之值，则搜索左子树；否则：
  4.查找右子树。
时间复杂度：O(log2(n)) 

4.哈希表法（散列表）：
条件：先创建哈希表（散列表）
原理：根据键值方式(Key Value)进行查找，通过散列函数，定位数据元素。
时间复杂度：几乎是O(1)，取决于产生冲突的多少。

5.分块查找：
思想：顺序查找和二分查找的结合。
原理：将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。然后使用二分查找及顺序查找。
时间复杂度：介于O(n)和O(logn)之间。

参考链接：https://blog.csdn.net/guoweimelon/article/details/50906299
